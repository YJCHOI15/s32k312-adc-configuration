# S32K312 ADC Part

## **ADC 파트 목표: ADC 값에 따른 4상태 LED 제어**

- 입력: 가변저항(ADC0_P0)의 아날로그 값을 ADC로 읽는다.
- 처리: 읽어온 ADC 값의 범위에 따라 4가지 상태(OFF, Red, Green, Blue) 중 하나를 결정한다.
- 출력: 결정된 상태에 따라 PTC10(Red), PTB17(Green), PTB16(Blue) GPIO 핀의 전압을 제어하여 해당 LED만 켠다.

## **1. Schematic 분석**

### **1-1. Variable Resistor**

- Easy Module Shield V1의 ROTATION(가변 저항)은 **A0** 핀에 연결된다.

<img width="195" height="174" alt="image" src="https://github.com/user-attachments/assets/4945431a-fede-4303-a6f2-58ec5812e8b6" /><BR><BR>


- 본 실습에서 A0가 **S32K312EVB**의 **PTD1**로 들어간다.

<img width="954" height="788" alt="image" src="https://github.com/user-attachments/assets/7a3289df-078a-4ab4-8d35-04180b8ffd85" />
<img width="1116" height="475" alt="image" src="https://github.com/user-attachments/assets/ab646ea4-77f5-4ae2-86c0-cb0883b0239d" /><BR><BR>


- 회로상 이 라인은 **ADC0_P0**에 매핑되어 있으므로, 가변저항을 돌리면 ADC0_P0 입력 전압이 연속적으로 변한다.

<img width="1396" height="91" alt="image" src="https://github.com/user-attachments/assets/60adc6d7-5088-4c69-be7b-5521b7fcf196" /><BR><BR>


### **1-2. RGB LED**

- Easy Module Shield V1의 **RGB LED**는 **D9, D10, D11**에 연결된다. (사진 표기와 다름)
- **Active High** 타입이므로, 해당 핀을 HIGH로 구동하면 LED가 켜진다.

<img width="317" height="177" alt="image" src="https://github.com/user-attachments/assets/535a41ed-2e28-4931-a3a6-1064b7d9af2f" /><BR><BR>


- 이번 실습에서는 쉴드의 RGB가 S32K312EVB의 **PTC10(R), PTB17(G), PTB16(B)**에 연결된다.

<img width="964" height="803" alt="image" src="https://github.com/user-attachments/assets/ce05cf77-090a-455c-a21d-4275922d15a8" />
<img width="1761" height="583" alt="image" src="https://github.com/user-attachments/assets/1ed20309-7467-4f43-a01f-4b91c305b0f0" /><BR><BR>


- 이 핀들의 SIUL2 MSCR 인덱스는 각각 **GPIO 74, 49, 48**에 대응한다.

---

## **2. Reference Manual 관점 정리**

### 2-1. 핀 기능 설정 (SIUL2)

> 문서: S32K3XXRM.pdf, Chapter 10: System Integration Unit Lite2 (SIUL2)

<BR>

**SIUL2(System Integration Unit Lite2)**는 핀의 기능/전기특성 멀티 플렉싱을 담당하는 모듈이다. 

<BR>

1. **LED 출력 핀 (`PTC10/PTB17/PTB16`):**
    
    `PTC10` , `PTB17` , `PTB16` 핀을 디지털 출력으로 설정한다. 
    
    SIUL2의 **MSCR(Multiplexed Signal Configuration Register)**에서 출력/입력 여부, 풀업/풀다운, 대체 기능(ALT) 선택 등 각 핀의 설정이 가능하다. 
    
    MSCRn의 인덱스는 아래 테이블에 따라 각각 74, 49, 48에 해당한다. 
    
    <img width="938" height="364" alt="image" src="https://github.com/user-attachments/assets/0592df49-093b-4340-a943-a01824e25551" /><BR><BR>

    
    1. **SIUL2 베이스 주소와 각 MSCR의 오프셋** 
        
        <img width="291" height="74" alt="image" src="https://github.com/user-attachments/assets/6713aa60-d907-4b6a-83ca-352f08d2103a" />
        <img width="915" height="72" alt="image" src="https://github.com/user-attachments/assets/6be08259-c8e5-43be-a393-462b39989194" />
        <img width="913" height="42" alt="image" src="https://github.com/user-attachments/assets/e40d84ca-ca0c-4e18-bb33-2ed0bbae802f" /><BR><BR>

        
    2. **SIUL2.MSCRn**
        
        <img width="1710" height="490" alt="image" src="https://github.com/user-attachments/assets/6c66668f-10bf-408c-856b-9fe45ea72b7e" /><BR><BR>

        
        - `SSS[3:0]` 를 ‘GPIO’ 기능으로 설정
            
            <img width="937" height="94" alt="image" src="https://github.com/user-attachments/assets/9abfa8a7-26d7-405f-851a-4f1bc0cf2573" /><BR><BR>

            
        - `OBE[21]` (Output Buffer Enable) 비트를 활성화(=1)하여 해당 핀이 출력으로 동작하도록 설정
      
<BR>

2. **ADC0 입력 핀 (`PTD1`):**
    
    > 문서: S32K312_IOMUX.xlsx, S32K312_IO_Signal Table
    > 

    ADC0_P0을 사용하기 위해 MSCR과 IMCR 모두 설정할 필요가 없다. 
    
    <img width="1440" height="417" alt="image" src="https://github.com/user-attachments/assets/1e6972ec-067d-48f0-9c20-e9daacbbd16e" /><BR><BR>

    

### 2-2. ADC0 클럭 준비 (MC_CGM)

> 문서: S32K3XXRM.pdf, Chapter 24: Clocking, Chapter 25: Clock Generation Module (MC_CGM)
> 

<BR>

먼저 S32K312는 **GPIO를 사용하기 위한 별도의 클럭 설정을 할 필요가 없다.** 
따라서 ADC0_P0을 사용하기 위한 클럭 설정만 해주면 된다. 

<img width="573" height="107" alt="image" src="https://github.com/user-attachments/assets/52492636-1dc7-4043-b508-f81fbcbe341b" /><BR><BR>


MC_CGM은 클럭 소스를 선택하고 분주하여 **후속 모듈이 쓸 클럭을 생성**한다. 

<BR>

ADC 모듈은 **CORE_CLK**를 공급받아 작동한다. 
실제로 ADC.MCR[ADCLKSEL]에서 CORE_CLK가 분주된 AD_CLK을 사용한다. 

<img width="360" height="231" alt="image" src="https://github.com/user-attachments/assets/219f234b-bb52-431e-b181-46d5e0acb4bd" /><BR><BR>


클럭 소스 **FIRC(내부 48MHz RC 클럭)**을 ADC 소스로 사용할 수 있다. 

FIRC_CLK는 MC_CGM_MUX_0_DC[DIV]를 통해 CORE_CLK이 되어 ADC로 공급된다. 

<img width="1269" height="827" alt="image" src="https://github.com/user-attachments/assets/1f6bd07c-fb8e-4e57-8d0c-ef4e387ca8cc" /><BR><BR>

<BR>

본 실습에서는 24Mhz를 사용한다: 

**FIRC_CLK(48MHz) → 1 분주 → CORE_CLK(48MHz) → ADC 모듈에서 2 분주**

<BR>

1. **MC_CGM 베이스 주소**
    
    <img width="251" height="55" alt="image" src="https://github.com/user-attachments/assets/f1e7f45e-317d-4f91-9fae-527177082370" /><BR><BR>


    

2. **MC_CGM.MUX_0_CSC[SELCTL]**
    
    CORE_CLK으로 FIRC과 PLL_PHI0_CLK 중 어떤 것을 사용할지 선택한다. 
    
    <img width="749" height="60" alt="image" src="https://github.com/user-attachments/assets/c7abff35-b11e-4c42-80db-1135877c1d9a" />
    <img width="1167" height="188" alt="image" src="https://github.com/user-attachments/assets/7a2c7f6f-7ac9-4b0b-83ef-20aaad2e1af4" /><BR><BR>

    

3. **MC_CGM.MUX_0_DC_0[DIV]**
    
    FIRC_CLK을 2로 분주하여 24 MHz CORE_CLK을 생성한다. 
    출력 클럭의 주기는 입력 클럭 주기의 **(DIV + 1) 배**
    
    <img width="748" height="59" alt="image" src="https://github.com/user-attachments/assets/337bce57-1292-494f-a3c5-d9a0af759033" />

    
    <img width="748" height="77" alt="image" src="https://github.com/user-attachments/assets/869f2d66-9d9e-44d7-8fef-fc865e446672" /><BR><BR>

    

### 2-3. ADC0 클럭 적용 (MC_ME, MC_CGM보다 먼저 설정)

> 문서: S32K3XXRM.pdf, Chapter 46: Mod Entry Module (MC_ME)
> 

<BR>

S32K3XX 칩의 코어, 주변장치는 전력/클럭 관리 단위로 **파티션**으로 나뉜다.

각 파티션 내부에서는 주변장치 클럭을 일괄 온/오프할 수 있도록 **Clock Off Block(COFB)**으로 묶어 관리한다. 

<BR>

**MC_ME**는 MC_CGM이 생성한 클럭을 파티션/COFB 단위로 게이팅, 매핑하여, 예를 들어 ADC0이 포함된 파티션 0번의 COFB 1번 구역에 공급되도록 허가한다.

<BR>

“*Table 260. MC_ME partition peripheral mapping and clock control*”에서 ADC0이 어느 파티션션/COFB에 속하는지를 확인할 수 있다.  

<img width="1000" height="34" alt="image" src="https://github.com/user-attachments/assets/b8fb88a2-7b2a-4a1d-aee6-7161292ad5b3" /><BR><BR>


먼저 파티션 0으로 클럭이 공급될 수 있도록 허가해야 한다. 이는 **PRTN_PCONF** 레지스터에서 설정하며, 파티션 전체의 ‘두꺼비집’ 역할을 한다. 

<BR>

그다음, “Figure 190. Peripheral initialization process”에 따라 `ADC0` 이 속한 파티션 0의 COFB를 열어 클럭을 받을 수 있도록 허가한다.  

<img width="596" height="725" alt="image" src="https://github.com/user-attachments/assets/2fc2a13b-14c3-4892-a11f-12492ca6970e" /><BR><BR>


1. **MC_ME 베이스 주소**
    
    <img width="231" height="55" alt="image" src="https://github.com/user-attachments/assets/94bcec93-4f24-4591-badf-84f886a072e2" /><BR><BR>


    

2. **MC_ME.PRTN0_PCONF[PCE]**
    
    파티션 0의 클럭을 켤지 여부를 결정한다. 
    
    **파티션 클럭 활성/비활성화는 정해진 순서(설정→업데이트→상태확인)** 에 따라 일관되게 처리해야 한다.  ****
    
    <img width="749" height="31" alt="image" src="https://github.com/user-attachments/assets/7ceb9c68-5fd4-4a64-b3ba-681089d01fdb" />
    <img width="749" height="127" alt="image" src="https://github.com/user-attachments/assets/dae6b304-f552-4170-8ff2-e720146dfa67" /><BR><BR>

    

3. **MC_ME.PRTN0_COFB1_CLKEN[REQ40]**
    
    파티션 0 의 COFB 1번 그룹(ADC0이 포함된 블록)에 대한 클럭 게이트 요청을 설정한다.  
    
    **리셋 후 기본값이 보장되지 않으므로, 반드시 명시적으로 1로 설정해야 한다.** 
    
    <img width="749" height="51" alt="image" src="https://github.com/user-attachments/assets/ea186b8c-7d9b-4813-8bab-a3f2298cb1da" />
    <img width="1166" height="192" alt="image" src="https://github.com/user-attachments/assets/89b95647-f2f5-41a1-bff6-20ca78769a2b" /><BR><BR>

    

4. **MC_ME.PRTN0_PUPD[PCUD]**
    
    파티션 0에 대해 앞서 설정한 변경 사항을 실제로 적용하기 위한 트리거를 건다.
    
    `PCUD` 비트를 1로 설정해 적용(파티션 클럭, COFB 클럭 게이트 변경)을 시작하면, 완료 시 하드웨어가 자동으로 0으로 되돌린다.  
    
    <img width="749" height="32" alt="image" src="https://github.com/user-attachments/assets/4c5b561b-d729-4efc-997c-e4e254c8668c" />
    <img width="751" height="137" alt="image" src="https://github.com/user-attachments/assets/b11ca5ce-70f7-4b36-989a-ee8b58283b19" /><BR><BR>

    
5. **MC_ME.CTL_KEY**
    
    의도치 않은 오작동을 막기 위해, 파티션 설정을 변경하기 위해 반드시 정해진 순서에 따라 **두 번에 걸쳐** 해당 레지스터에 올바른 Key를 입력해야 한다. 
    
    먼저 정해진 키 값(`0x5AF0`)을 쓴다. 
    
    그 다음, 첫 번째 키의 반전된 키 값 (`0xA50F`)을 쓴다. 
    
    <img width="748" height="30" alt="image" src="https://github.com/user-attachments/assets/8882b822-4ed6-4274-9dd8-a2e0e59fbb12" />
    <img width="750" height="82" alt="image" src="https://github.com/user-attachments/assets/fc0b7184-520c-45cd-9207-f3f625a2f90b" />
    
    만약 두 키값이 올바르지 않다면 전 단계(PUPD)에서 설정한 내용이 무시된다. 

<BR>

### 2-4. ADC0 설정 및 값 읽기 (ADC)

> 문서: S32K3XXRM.pdf, Chapter 60: Analog-to-Digital Converter (ADC)
> 

<BR>

1. **ADC_0 베이스 주소**
    
    <img width="228" height="58" alt="image" src="https://github.com/user-attachments/assets/eedc8bb7-5e63-4031-9bd5-126c935eac01" />

    

2. **ADC_0.MCR**
    
    대부분의 ADC 기능을 설정한다. 반드시 ADC가 IDLE일 때만 변경해야 한다. 
    
    <img width="750" height="30" alt="image" src="https://github.com/user-attachments/assets/facdafe0-19ba-4184-a8d6-9542ac0e2a71" />
    <img width="766" height="229" alt="image" src="https://github.com/user-attachments/assets/42ebb773-7066-4cd9-87f1-54e95cb8a76f" /><BR><BR>

    
    `NSTART` - 일반 변환을 시작시키는 트리거 역할을 한다. 단일 변환 모드일 경우 (`MODE` = 0) 변환 시작 후 필드 값은 자동으로 0이 됨
    
    <img width="750" height="204" alt="image" src="https://github.com/user-attachments/assets/884fa1ad-359d-4a03-a903-75fddd6efdcc" />
    <img width="749" height="62" alt="image" src="https://github.com/user-attachments/assets/3e48b210-f61b-44ae-a4de-ba8189faec37" />
    <img width="748" height="149" alt="image" src="https://github.com/user-attachments/assets/52857a2e-e4ee-4fff-a735-264b83bb1092" /><BR><BR>

    
    `ADCLKSEL` - 클럭 신호 주파수를 선택 (CORE_CLK(48Mhz) → AD_CLK(24Mhz)), 반드시 파워 다운 상태(`PWDN` = 1)일 때만 값을 쓸 수 있음
    
    <img width="750" height="188" alt="image" src="https://github.com/user-attachments/assets/7101e46f-fa16-45c9-9b48-f52940c7170c" />
    <img width="748" height="63" alt="image" src="https://github.com/user-attachments/assets/6ac4de40-90c4-406c-a641-aff559d6b407" />
    <img width="748" height="64" alt="image" src="https://github.com/user-attachments/assets/466afc05-e559-4040-8578-877717bfbfe9" /><BR><BR>

    

3. **ADC_0.ISR[EOC]**
    
    **Normal Conversion이 완료된 후** 생성되는 **변환 완료(EOC) 인터럽트의 상태**를 나타낸다. 
    
    <img width="1677" height="69" alt="image" src="https://github.com/user-attachments/assets/8bf827c2-ac29-44c0-95c8-ab2d8af9c38f" />
    <img width="836" height="333" alt="image" src="https://github.com/user-attachments/assets/3ea914b9-101a-4f8b-976f-e224399035d8" /><BR><BR>

    

4. **ADC_0.NCMR0[CH0]**
    
    일반 변환 동안에 변환될 precision input 채널을 선택한다. 
    
    <img width="751" height="31" alt="image" src="https://github.com/user-attachments/assets/5708829f-c135-40e5-a645-a70e0b40b323" />
    <img width="749" height="119" alt="image" src="https://github.com/user-attachments/assets/1b877460-e441-4269-a25f-7b8acdbb79d1" /><BR><BR>

    

5. **ADC_0.PCDR0**
    
    Precision input 0 채널의 변환 데이터를 저장한다. 
    
    <img width="751" height="32" alt="image" src="https://github.com/user-attachments/assets/8ce064be-d496-4d58-bbac-918d6c2179f3" />
    <img width="750" height="60" alt="image" src="https://github.com/user-attachments/assets/5fbfda2e-832d-4d04-9a5d-8be330d08444" />
    <img width="763" height="222" alt="image" src="https://github.com/user-attachments/assets/1eef5f49-4620-41cc-adfa-637c710df78e" /><BR><BR>

    
    `VALID` - ADC 변환 완료 후 아직 읽지 않은 새로운 데이터가 있으면 1이 됨
    
    `OVERW` - VALID가 1인 상태에서 ADC가 또 다른 변환을 완료하면 새 데이터로 교체되고 1이 됨
    
    `RESULT` - 현재 데이터가 어떤 종류의 트리거에 의해 생성된 결과인지 구별 가능
    
    `CDATA` :
    
    - 아날로그 전압이 디지털 값으로 변환된 최종 결과물
    - 기본 오른쪽 정렬로 [14:0]를 사용
    - 12비트 해상도인 경우 CDATA[14:0]의 왼쪽 12비트[14:3]에 변환값이 저장
    
    <img width="750" height="81" alt="image" src="https://github.com/user-attachments/assets/bc708652-b0ef-4681-a616-e5749311200b" />
    <img width="750" height="503" alt="image" src="https://github.com/user-attachments/assets/8d249134-6bd9-4021-a3aa-99c3a9d6a5c8" /><BR><BR>

    
6. **ADC_0.CALBISTREG**
    
    데이터 변환, 캘리브레이션과 캘리브레이션 상태와 관련된 여러 ADC 기능들을 제어한다. 
    
    <img width="748" height="31" alt="image" src="https://github.com/user-attachments/assets/83b6a17d-c451-4cd1-b3e5-ebe1bf00f762" />
    <img width="766" height="233" alt="image" src="https://github.com/user-attachments/assets/32d7184f-68f1-4937-8c92-deee741d1ae4" /><BR><BR>

    

    `RESN` - 해상도 설정 (기본값 12비트 사용), **ADC IDLE 상태(변환 중이 아닐 때)에서 변경해야 함**

    <img width="748" height="205" alt="image" src="https://github.com/user-attachments/assets/d61f4742-2983-4b3d-baa0-c99f4ef39fdd" /><BR><BR>


    `C_T_BUSY` - 현재 캘리브레이션이 진행 중 여부 플래그

    <img width="748" height="116" alt="image" src="https://github.com/user-attachments/assets/13540ab6-4dc7-49ea-8928-017f5f1a2199" /><BR><BR>


    `TEST_FAIL` - 캘리브레이션 결과 플래그

    <img width="752" height="86" alt="image" src="https://github.com/user-attachments/assets/588d3989-ec8e-4c67-beda-5ee781bf834a" />
    <img width="751" height="256" alt="image" src="https://github.com/user-attachments/assets/b3de7a88-733f-4b66-b767-a7d0c27b6924" /><BR><BR>


    `TEST_EN` - 캘리브레이션 시작

    <img width="748" height="118" alt="image" src="https://github.com/user-attachments/assets/f65e234e-2295-45fa-9fe2-6faf42515723" /><BR><BR>


### 2-5. GPIO 출력 제어 (SIUL2)

> 문서: S32K3XXRM.pdf, Chapter
>

<BR>

제어할 LED는 **Active HIGH** 방식으로 동작한다. 이는 GPIO 핀의 전압이 **HIGH** 상태가 될 때 LED가 켜진다는 의미이다. 따라서 LED를 켜기 위해서는 해당 GPIO 핀에 **1**을 써야 한다.

<BR>

GPIO 핀의 출력 상태(HIGH/LOW)는 **`SIUL2`** 모듈의 **`GPDO` (GPIO Pad Data Output)** 레지스터를 통해 직접 제어할 수 있다.

<BR>

**SIUL2.GPDOn[PDO_n]**

<img width="751" height="177" alt="image" src="https://github.com/user-attachments/assets/394bdca6-0b97-4db3-9c93-eda038716604" />
<img width="749" height="161" alt="image" src="https://github.com/user-attachments/assets/c4cc3b21-e811-44bc-910e-c69ff8259396" /><BR><BR>


**`PDO_n`** - `GPDO` 레지스터 내의 각 비트(`PDO_n`)는 개별 GPIO 핀(n번 핀)에 직접 대응된다.
