# S32K312 ADC Part

## **ADC 파트 목표: ADC 값에 따른 4상태 LED 제어**

- 입력: 가변저항(ADC0_P0)의 아날로그 값을 ADC로 읽는다.
- 처리: 읽어온 ADC 값의 범위에 따라 4가지 상태(OFF, Red, Green, Blue) 중 하나를 결정한다.
- 출력: 결정된 상태에 따라 PTC10(Red), PTB17(Green), PTB16(Blue) GPIO 핀의 전압을 제어하여 해당 LED만 켠다.

## **1. Schematic 분석**

### **1-1. Variable Resistor**

- Easy Module Shield V1의 ROTATION(가변 저항)은 **A0** 핀에 연결된다.

![image.png](attachment:7fa166fa-6af8-49be-9fb2-8c2b949b631b:image.png)

- 본 실습에서 A0가 **S32K312EVB**의 **PTD1**로 들어간다.

![image.png](attachment:aa787b42-cca2-4cc4-8744-fea1a3ac1457:image.png)

![image.png](attachment:65041cf0-58e2-4ed8-921e-c92d6b071113:image.png)

- 회로상 이 라인은 **ADC0_P0**에 매핑되어 있으므로, 가변저항을 돌리면 ADC0_P0 입력 전압이 연속적으로 변한다.

![image.png](attachment:deb99247-e70e-4911-8f35-4eb9ffb1c9c8:image.png)

### **1-2. RGB LED**

- Easy Module Shield V1의 **RGB LED**는 **D9, D10, D11**에 연결된다. (사진 표기와 다름)
- **Active High** 타입이므로, 해당 핀을 HIGH로 구동하면 LED가 켜진다.

![image.png](attachment:d27da61b-6fef-486a-bfa8-1e3e2b5fe0f4:image.png)

- 이번 실습에서는 쉴드의 RGB가 S32K312EVB의 **PTC10(R), PTB17(G), PTB16(B)**에 연결된다.

![image.png](attachment:8632d6b4-8e42-4ac2-b3ad-757df6cb6ecb:image.png)

![image.png](attachment:00cf96e3-fefb-4d04-85f6-760ea2edbbf1:image.png)

- 이 핀들의 SIUL2 MSCR 인덱스는 각각 **GPIO 74, 49, 48**에 대응한다.

---

## **2. Reference Manual 관점 정리**

### 2-1. 핀 기능 설정 (SIUL2)

> 문서: S32K3XXRM.pdf, Chapter 10: System Integration Unit Lite2 (SIUL2)
> 

**SIUL2(System Integration Unit Lite2)**는 핀의 기능/전기특성 멀티 플렉싱을 담당하는 모듈이다. 

1. **LED 출력 핀 (`PTC10/PTB17/PTB16`):**
    
    `PTC10` , `PTB17` , `PTB16` 핀을 디지털 출력으로 설정한다. 
    
    SIUL2의 **MSCR(Multiplexed Signal Configuration Register)**에서 출력/입력 여부, 풀업/풀다운, 대체 기능(ALT) 선택 등 각 핀의 설정이 가능하다. 
    
    MSCRn의 인덱스는 아래 테이블에 따라 각각 74, 49, 48에 해당한다. 
    
    ![image.png](attachment:3fd8ec0b-00eb-43d9-b7fc-2456de662557:image.png)
    
    1. **SIUL2 베이스 주소와 각 MSCR의 오프셋** 
        
        ![image.png](attachment:586cc07b-0b7b-4096-8388-dfd4ec782389:image.png)
        
        ![image.png](attachment:50f81476-6766-459e-afc6-87fee11b49db:image.png)
        
        ![image.png](attachment:cce2f776-d52c-4f32-b5f5-f811566647cc:image.png)
        
    2. **SIUL2.MSCRn**
        
        ![image.png](attachment:3968a9dc-d90c-40d6-be35-35396f7a36c0:image.png)
        
        - `SSS[3:0]` 를 ‘GPIO’ 기능으로 설정
            
            ![image.png](attachment:f78f9596-6ff9-41c9-9477-3962bd4fd16a:image.png)
            
        - `OBE[21]` (Output Buffer Enable) 비트를 활성화(=1)하여 해당 핀이 출력으로 동작하도록 설정

1. **ADC0 입력 핀 (`PTD1`):**
    
    > 문서: S32K312_IOMUX.xlsx, S32K312_IO_Signal Table
    > 
    
    ADC0_P0을 사용하기 위해 MSCR과 IMCR 모두 설정할 필요가 없다. 
    
    ![image.png](attachment:f6ac9f3a-8ea8-4d3b-85fb-bc2da37d5fbe:image.png)
    

### 2-2. ADC0 클럭 준비 (MC_CGM)

> 문서: S32K3XXRM.pdf, Chapter 24: Clocking, Chapter 25: Clock Generation Module (MC_CGM)
> 

MC_CGM은 클럭 소스를 선택하고 분주하여 **후속 모듈이 쓸 클럭을 생성**한다. 

ADC 모듈은 **CORE_CLK**를 공급받아 작동한다. 

실제로 ADC.MCR[ADCLKSEL]에서 CORE_CLK가 분주된 AD_CLK을 사용한다. 

![image.png](attachment:e9442d48-1e89-47d1-864b-b97f6e972447:image.png)

클럭 소스 **FIRC(내부 48MHz RC 클럭)**을 ADC 소스로 사용할 수 있다. 

FIRC_CLK는 MC_CGM_MUX_0_DC[DIV]를 통해 CORE_CLK이 되어 ADC로 공급된다. 

![image.png](attachment:77b14eaf-44d3-4bc0-a0a8-58e928047b4d:image.png)

본 실습에서는 24Mhz를 사용한다: 

**FIRC_CLK(48MHz) → 1 분주 → CORE_CLK(48MHz) → ADC 모듈에서 2 분주**

1. **MC_CGM 베이스 주소**
    
    ![image.png](attachment:f9ead5f9-bd78-4e40-91a8-87d8076b3a5c:image.png)
    

1. **MC_CGM.MUX_0_CSC[SELCTL]**
    
    CORE_CLK으로 FIRC과 PLL_PHI0_CLK 중 어떤 것을 사용할지 선택한다. 
    
    ![image.png](attachment:2d9bc46a-726d-4d3b-afae-1119824a0332:image.png)
    
    ![image.png](attachment:abbe2f1b-782f-4142-b092-1bfa5d6e7dcf:image.png)
    

1. **MC_CGM.MUX_0_DC_0[DIV]**
    
    FIRC_CLK을 2로 분주하여 24 MHz CORE_CLK을 생성한다. 
    출력 클럭의 주기는 입력 클럭 주기의 **(DIV + 1) 배**
    
    ![image.png](attachment:773d205f-11fb-416e-8a7d-d2a82cf6a0c7:image.png)
    
    ![image.png](attachment:b628acef-1e65-4b24-a8f0-a2285bbab023:image.png)
    

### 2-3. ADC0 클럭 적용 (MC_ME, MC_CGM보다 먼저 설정)

> 문서: S32K3XXRM.pdf, Chapter 46: Mod Entry Module (MC_ME)
> 

S32K3XX 칩의 코어, 주변장치는 전력/클럭 관리 단위로 **파티션**으로 나뉜다.

각 파티션 내부에서는 주변장치 클럭을 일괄 온/오프할 수 있도록 **Clock Off Block(COFB)**으로 묶어 관리한다. 

**MC_ME**는 MC_CGM이 생성한 클럭을 파티션/COFB 단위로 게이팅, 매핑하여, 예를 들어 ADC0이 포함된 파티션 0번의 COFB 1번 구역에 공급되도록 허가한다.

“*Table 260. MC_ME partition peripheral mapping and clock control*”에서 ADC0이 어느 파티션션/COFB에 속하는지를 확인할 수 있다.  

![image.png](attachment:df303690-a069-41c7-8a52-db574718cd1a:image.png)

먼저 파티션 0으로 클럭이 공급될 수 있도록 허가해야 한다. 이는 **PRTN_PCONF** 레지스터에서 설정하며, 파티션 전체의 ‘두꺼비집’ 역할을 한다. 

그다음, “Figure 190. Peripheral initialization process”에 따라 `ADC0` 이 속한 파티션 0의 COFB를 열어 클럭을 받을 수 있도록 허가한다.  

![image.png](attachment:c1a95b01-13f4-45e7-bcb0-2e4cdbda6344:image.png)

1. **MC_ME 베이스 주소**
    
    ![image.png](attachment:66c1c74e-9e22-4cef-bb06-46d3cd21fbda:image.png)
    

1. **MC_ME.PRTN0_PCONF[PCE]**
    
    파티션 0의 클럭을 켤지 여부를 결정한다. 
    
    **파티션 클럭 활성/비활성화는 정해진 순서(설정→업데이트→상태확인)** 에 따라 일관되게 처리해야 한다.  ****
    
    ![image.png](attachment:94e9a395-7dde-4a7b-a71c-1228a61f3ae4:image.png)
    
    ![image.png](attachment:6802a4be-9262-4cb1-8d86-66e751d4bfb7:image.png)
    

1. **MC_ME.PRTN0_COFB1_CLKEN[REQ40]**
    
    파티션 0 의 COFB 1번 그룹(ADC0이 포함된 블록)에 대한 클럭 게이트 요청을 설정한다.  
    
    **리셋 후 기본값이 보장되지 않으므로, 반드시 명시적으로 1로 설정해야 한다.** 
    
    ![image.png](attachment:4d976e12-a599-4540-818f-4c1271e1caed:image.png)
    
    ![image.png](attachment:79e7d47f-56c4-49b3-a752-6757730e193d:image.png)
    

1. **MC_ME.PRTN0_PUPD[PCUD]**
    
    파티션 0에 대해 앞서 설정한 변경 사항을 실제로 적용하기 위한 트리거를 건다.
    
    `PCUD` 비트를 1로 설정해 적용(파티션 클럭, COFB 클럭 게이트 변경)을 시작하면, 완료 시 하드웨어가 자동으로 0으로 되돌린다.  
    
    ![image.png](attachment:fec8b014-f4c5-4368-ac9d-f9e53e9569b8:image.png)
    
    ![image.png](attachment:8f839a44-b846-4622-a2f0-89f57bb26193:image.png)
    
2. **MC_ME.CTL_KEY**
    
    의도치 않은 오작동을 막기 위해, 파티션 설정을 변경하기 위해 반드시 정해진 순서에 따라 **두 번에 걸쳐** 해당 레지스터에 올바른 Key를 입력해야 한다. 
    
    먼저 정해진 키 값(`0x5AF0`)을 쓴다. 
    
    그 다음, 첫 번째 키의 반전된 키 값 (`0xA50F`)을 쓴다. 
    
    ![image.png](attachment:dd1d61d7-a6c4-43dd-80e9-760376bfd05d:image.png)
    
    ![image.png](attachment:28fc350f-e6ef-4a25-8b05-59cb0a1eeaec:image.png)
    
    만약 두 키값이 올바르지 않다면 전 단계(PUPD)에서 설정한 내용이 무시된다. 
    

### 2-4. ADC0 설정 및 값 읽기 (ADC)

> 문서: S32K3XXRM.pdf, Chapter 60: Analog-to-Digital Converter (ADC)
> 

1. **ADC_0 베이스 주소**
    
    ![image.png](attachment:769b9a2c-2e3d-4ae9-8ea8-c8d130ec6127:image.png)
    

1. **ADC_0.MCR**
    
    대부분의 ADC 기능을 설정한다. 반드시 ADC가 IDLE일 때만 변경해야 한다. 
    
    ![image.png](attachment:7b2e1b14-eb5f-4b80-b693-28836dd7a0f8:image.png)
    
    ![image.png](attachment:9ea267ac-fce0-4fa4-819e-cf8e32babff8:image.png)
    
    `NSTART` - 일반 변환을 시작시키는 트리거 역할을 한다. 단일 변환 모드일 경우 (`MODE` = 0) 변환 시작 후 필드 값은 자동으로 0이 된다. 
    
    ![image.png](attachment:71cd18ba-d0b5-4477-ac80-a89d5ab98465:image.png)
    
    ![image.png](attachment:fd842e42-d407-43fe-ae36-37d5cf37abc2:image.png)
    
    ![image.png](attachment:ae08e442-65f5-4665-b040-a93475eec507:image.png)
    
    `ADCLKSEL` - 클럭 신호 주파수를 선택 (CORE_CLK(48Mhz) → AD_CLK(24Mhz)), 반드시 파워 다운 상태(`PWDN` = 1)일 때만 값을 쓸 수 있다. 
    
    ![image.png](attachment:1804db43-eea6-478d-b7ea-e2ce87149ae5:image.png)
    
    ![image.png](attachment:d3023a9d-cf0b-423a-85d7-0efa5a52a4ed:image.png)
    
    ![image.png](attachment:7473d250-1c30-425e-9291-b427a753683a:image.png)
    

1. **ADC_0.ISR[EOC]**
    
    **Normal Conversion이 완료된 후** 생성되는 **변환 완료(EOC) 인터럽트의 상태**를 나타낸다. 
    
    ![image.png](attachment:9046b48a-d0ac-4eb7-9924-0d801358cc0e:image.png)
    
    ![image.png](attachment:63b9b01a-a55c-457b-91bd-8100e8df8abe:image.png)
    

1. **ADC_0.NCMR0[CH0]**
    
    일반 변환 동안에 변환될 precision input 채널을 선택한다. 
    
    ![image.png](attachment:a2666cc7-c385-4ad7-8a7a-1e9c9111c231:image.png)
    
    ![image.png](attachment:9d71761b-afde-4cb8-8ce4-6c49b5a8621e:image.png)
    

1. **ADC_0.PCDR0**
    
    Precision input 0 채널의 변환 데이터를 저장한다. 
    
    ![image.png](attachment:6ddd27c6-d23f-4058-9658-b3c77b6e4516:image.png)
    
    ![image.png](attachment:cae745cb-19cb-4b9b-98dc-802586b9c8c2:image.png)
    
    ![image.png](attachment:cb350ff7-ea28-4ac1-bb90-ce1385823b9c:image.png)
    
    `VALID` - ADC 변환 완료 후 아직 읽지 않은 새로운 데이터가 있으면 1이 됨
    
    `OVERW` - VALID가 1인 상태에서 ADC가 또 다른 변환을 완료하면 새 데이터로 교체되고 1이 됨
    
    `RESULT` - 현재 데이터가 어떤 종류의 트리거에 의해 생성된 결과인지 구별 가능
    
    `CDATA` - 아날로그 전압이 디지털 값으로 변환된 최종 결과물
    
    ![image.png](attachment:5adf546b-0c83-4aca-a5c7-daa0434647ec:image.png)
    
    ![image.png](attachment:520ec775-07cf-41db-8733-4f3be8dec18a:image.png)
    
2. **ADC_0.CALBISTREG**
    
    데이터 변환, 캘리브레이션과 캘리브레이션 상태와 관련된 여러 ADC 기능들을 제어한다. 
    
    ![image.png](attachment:42834ebf-3ec6-4ac6-8a24-37febceb89a3:image.png)
    
    ![image.png](attachment:58d84b6d-5373-4090-984d-22ef012507ed:image.png)
    

`RESN` - 해상도 설정, 비트 수를 높이면 정밀도가 높아지지만 변환 속도가 느려짐 (12비트 해상도: 2의 12제곱 → 4096 단계)

![image.png](attachment:2d2599ef-a74f-4bbf-9952-8b328bf5bd62:image.png)

`C_T_BUSY` - 현재 캘리브레이션이 진행 중 여부 플래그

![image.png](attachment:5458c2f9-7684-4670-a228-64cfe997a80a:image.png)

`TEST_FAIL` - 캘리브레이션 결과 플래그

![image.png](attachment:6ccd6322-925a-4737-96ed-f54456a34152:image.png)

![image.png](attachment:24381f75-1cbe-4d4e-95c9-ccd1b3434903:image.png)

`TEST_EN` - 캘리브레이션 시작

![image.png](attachment:2a958467-17a4-4b13-82bc-2aa3b79c113b:image.png)

### 2-5. GPIO 출력 제어 (SIUL2)

> 문서: S32K3XXRM.pdf, Chapter
> 

제어할 LED는 **Active HIGH** 방식으로 동작한다. 이는 GPIO 핀의 전압이 **HIGH** 상태가 될 때 LED가 켜진다는 의미이다. 따라서 LED를 켜기 위해서는 해당 GPIO 핀에 **1**을 써야 한다.

GPIO 핀의 출력 상태(HIGH/LOW)는 **`SIUL2`** 모듈의 **`GPDO` (GPIO Pad Data Output)** 레지스터를 통해 직접 제어할 수 있다.

**SIUL2.GPDOn[PDO_n]**

![image.png](attachment:490eed98-35fe-4dde-8309-7e05716ac34c:image.png)

![image.png](attachment:e61e6562-0644-4c0d-9368-322131bc3846:image.png)

**`PDO_n`** - `GPDO` 레지스터 내의 각 비트(`PDO_n`)는 개별 GPIO 핀(n번 핀)에 직접 대응된다.